<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NULL、0、nullptr的区别</title>
    <url>/2020/03/27/NULL%E3%80%810%E3%80%81nullptr%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="NULL、0、nullptr的区别"><a href="#NULL、0、nullptr的区别" class="headerlink" title="NULL、0、nullptr的区别"></a>NULL、0、nullptr的区别</h1><p><strong>非原创，觉得作者写的很挺好，转自 <a href="https://www.cnblogs.com/nothx/p/8523191.html" target="_blank" rel="noopener">https://www.cnblogs.com/nothx/p/8523191.html</a></strong></p>
<p>某些时候，我们需要将指针赋值为空指针，以防止野指针。</p>
<p>有人喜欢使用NULL作为空指针常量使用，例如：int* p = NULL; 。</p>
<p>也有人直接使用0值作为空指针常量，例如：int* p = 0; 。</p>
<p>前者可能觉得：NULL作为空指针常量，名字很形象，可读性较强。</p>
<p>后者可能觉得：NULL并不是C/C++语言的关键字，而是一个在标准库头文件&lt;stddef.h&gt;中定义的宏，因此要使用NULL，可能需要直接或简介地包含&lt;stddef.h&gt;头文件，比较麻烦。</p>
<a id="more"></a>

<h2 id="问题一：NULL与常数0值有何区别？"><a href="#问题一：NULL与常数0值有何区别？" class="headerlink" title="问题一：NULL与常数0值有何区别？"></a>问题一：NULL与常数0值有何区别？</h2><p>要弄清楚这个问题，我们采用问与答的形式来描述。</p>
<p><strong>问：</strong>NULL到底是什么？</p>
<p><strong>答：</strong>NULL是一个宏。</p>
<p><strong>问：</strong>它的值是多少？</p>
<p><strong>答：</strong>C/C++标准规定：它的值是一个空指针常量（null pointer constant），由实现定义。#1,#2</p>
<p><strong>问：</strong>什么样的值才能称之为空指针常量？</p>
<p><strong>答：</strong>C语言中常数0和(void*)0都是空指针常量；C++中（暂且忽略C++11）常数0是，而(void*)0 不是。#3,#4</p>
<p><strong>问：</strong>NULL宏是在哪里定义的？</p>
<p><strong>答：</strong>通常是在C标准库的&lt;stddef.h&gt;头文件中，不过别的头文件中可能也有定义。</p>
<p><strong>问：</strong>一般编译器的&lt;stddef.h&gt;头文件中NULL宏是如何定义的？</p>
<p><strong>答：</strong>以gcc或clang编译器为例，NULL的定义大致如下（稍有简化）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NULL 0    <span class="comment">// C++中使用0作为NULL的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NULL ((void *)0)    <span class="comment">// C中使用((void *)0)作为NULL的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>问：为什么C中(void*)0是空指针常量，而C++中不是？</p>
<p>答：因为C语言中任何类型的指针都可以（隐式地）转换为 void* 型，反过来也行，而C++中 void* 型不能隐式地转换为别的类型指针（例如：int* p = (void*) 0;使用C++编译器编译会报错）。#5,#6</p>
<p>问：既然C/C++标准中，常数0都可作为空指针常量，为什么不统一使用0？</p>
<p>答：个人觉得由于(void*)0更能体现指针的意义，而常数0更多的时候是用作整数。因此，C语言中NULL定义选择了(void*)0。（仅供参考）</p>
<h2 id="问题二：C-11中为什么要引入nullptr？"><a href="#问题二：C-11中为什么要引入nullptr？" class="headerlink" title="问题二：C++11中为什么要引入nullptr？"></a>问题二：C++11中为什么要引入nullptr？</h2><p>考虑着这样一个函数重载的情形：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;     <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span> </span>&#123;&#125;   <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo(<span class="literal">NULL</span>); <span class="comment">// 调用#1还是#2？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字面上来讲，NULL是个空指针常量，我们可能会觉得：既然是个指针，那么应该调用#2。但事实上调用的却是#1，因为C++中NULL扩展为常数0，它是int型。</p>
<p>根本原因就是：常数0既是整数常量，也是空指针常量。</p>
<p>为了解决这种二义性，C++11标准引入了关键字nullptr，它作为一种空指针常量。#7</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;     <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span> </span>&#123;&#125;   <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo(<span class="literal">nullptr</span>); <span class="comment">// 它会毫无异议地调用#2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>附注：</strong></p>
<p>[#1] C99: 7.17-p3:</p>
<p>  The macros are NULL which expands to an implementation-defined null pointer constant; and …</p>
<p>[#2] C++03: 18.1-p4:</p>
<p>  The macro NULL is an implementation-defined C + + null pointer constant in this International Standard(4.10).</p>
<p>[#3] C99: 6.3.2.3-p3:</p>
<p>  An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.</p>
<p>[#4] C++03: 4.10-p1:</p>
<p>  A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to zero.</p>
<p>[#5] C99: 6.3.2.3-p1:</p>
<p>  A pointer to void may be converted to or from a pointer to any incomplete or object type. A pointer to any incomplete or object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer.</p>
<p>[#6] C++03: 4.10-p2:</p>
<p>  An rvalue of type “pointer to cv T,” where T is an object type, can be converted to an rvalue of type “pointer to cv void.”</p>
<p>[#7] C++11: 4.10-p1:</p>
<p>  A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type std::nullptr_t.</p>
</blockquote>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>电信光猫TWEA-600AEM超级密码获取</title>
    <url>/2020/02/01/%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%ABTWEA-600AEM%E8%B6%85%E7%BA%A7%E5%AF%86%E7%A0%81%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h1 id="电信光猫TWEA-600AEM超级密码获取"><a href="#电信光猫TWEA-600AEM超级密码获取" class="headerlink" title="电信光猫TWEA-600AEM超级密码获取"></a>电信光猫TWEA-600AEM超级密码获取</h1><h2 id="登录光猫"><a href="#登录光猫" class="headerlink" title="登录光猫"></a>登录光猫</h2><p>电信给配的光猫型号是TWEA-600AEM，这个光猫只有一个千兆网口，一个百兆网口和一个USB口，一个电话插口，相比其他地区同时安装的光猫，性能不是太好。</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210214658.jpg" alt=""></p>
<p>这个光猫自带无线2.4G WiFi功能，属于能用级别，最好购买个好点的路由器。</p>
<p>WIFI名称默认是ChinaNet-XXXX（不同的光猫只有XXXX不同）。默认WiFi名称和WiFi密码都写在标签上，标签上还有光猫默认管理地址、默认终端配置账号和默认终端配置密码等各种信息。这里的默认终端配置账号其实就是普通管理用户，只能进入管理界面查看部分信息，修改光猫局域网地址，修改WiFi名称、密码等。</p>
<a id="more"></a>

<p>查看光猫底部标签，获得光猫管理IP地址和管理员用户登录密码。地址一般为<a href="http://192.168.1.1/" target="_blank" rel="noopener">http://192.168.1.1/</a>  ，使用标签上的用户名和密码登录。</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210214733.jpg" alt=""></p>
<p>登录后的界面如下：</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210214747.jpg" alt=""></p>
<h2 id="超级密码获取"><a href="#超级密码获取" class="headerlink" title="超级密码获取"></a>超级密码获取</h2><p>登录后不退出，打开<a href="http://192.168.1.1/backupsettings.conf即可下载文件。访问http://192.168.1.1/dumpcfg.conf" target="_blank" rel="noopener">http://192.168.1.1/backupsettings.conf即可下载文件。访问http://192.168.1.1/dumpcfg.conf</a> 也可以，但是文件内容不如前者清晰。</p>
<p>下载后用文本编辑软件打开，自带的记事本等都可以，为了好展示，我用的是Sublime Text 3。</p>
<p>网上的教程是：Ctrl+F查找telecomadmin ，一般密码是telecomadmin+8位数字。回到光猫管理页面，退出普通用户，然后用这个用户名telecomadmin，密码telecomadmin+8位数字登录光猫。如下图：</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210214833.jpg" alt=""></p>
<p>但是文件里并没有，仔细查看文件，发现了password关键字，用来登录，成功了！</p>
<p>编号1处是超级密码，用户名是useradmin或者telecomadmin都可以登录。</p>
<p>编号2处光猫普通管理员密码。2个密码都是明文，可以直接登录。</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210214816.jpg" alt=""></p>
<p>登录后的界面如下，可以查看更多高级信息，非专业人士请勿修改，以免不能上网。</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210214849.jpg" alt=""></p>
<p>但是很多按钮是灰色的不能点击，貌似通过删除 <code>disabled=&quot;true&quot;</code>元素来使按钮生效。我没有用过，谨慎修改。</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200210222523.jpg" alt=""></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>光猫</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 下基于Snort的入侵检测系统的搭建</title>
    <url>/2019/07/20/snort/</url>
    <content><![CDATA[<h1 id="Ubuntu-下基于Snort的入侵检测系统的搭建"><a href="#Ubuntu-下基于Snort的入侵检测系统的搭建" class="headerlink" title="Ubuntu 下基于Snort的入侵检测系统的搭建"></a>Ubuntu 下基于Snort的入侵检测系统的搭建</h1><h2 id="Snort概览"><a href="#Snort概览" class="headerlink" title="Snort概览"></a>Snort概览</h2><p>Snort IDS（入侵检测系统）是一个强大的网络入侵检测系统。它具有实时数据流量分析和记录IP网络数据包的能力，能够进行协议分析，对网络数据包内容进行搜索、匹配。它能够检测各种不同的攻击方式，对攻击进行实时报警。此外，Snort是开源的入侵检测系统，并具有很好的扩展性和可移植性。</p>
<p>snort官网：<a href="https://www.snort.org/" target="_blank" rel="noopener">https://www.snort.org/</a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>snort官网有很多教程，官方使用手册，不同平台的安装教程，等其他由snort社区成员编写的很多教程，都非常的详细，是非常好的参考资料，不过都是英文的。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190719234643.jpg" alt=""></p>
<p>详见：<a href="https://www.snort.org/documents" target="_blank" rel="noopener">https://www.snort.org/documents</a></p>
<h2 id="安装案例"><a href="#安装案例" class="headerlink" title="安装案例"></a>安装案例</h2><p>Ubuntu 16.04下snort+barnyard2+base的入侵检测系统的搭建</p>
<p><strong>安装教程</strong></p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190720001200.png" alt=""></p>
<p>作者博客：<a href="http://sublimerobots.com/" target="_blank" rel="noopener">http://sublimerobots.com/</a></p>
<p><strong>Snort</strong>：检测攻击</p>
<blockquote>
<p>Snort可以以人类可读模式将事件写入控制台或文本文件，但是比较耗费资源，效率不高，影响Snort性能。</p>
</blockquote>
<p><strong>Barnyard2</strong>：将告警信息保存到数据库</p>
<blockquote>
<p>Barnyard2是一个用于Snort unified2二进制输出文件的开源解释器，<a href="https://github.com/firnsy/barnyard2" target="_blank" rel="noopener">https://github.com/firnsy/barnyard2</a></p>
<p>将Snort事件存储在MySQL数据库中，这样我们就可以查看、搜索和查找事件。</p>
<p>为了有效地将Snort事件放入MySQL数据库，减少Snort的负载。可以使用Barnyard2。配置Snort将事件以二进制形式输出到一个文件夹中，然后让Barnyard2异步读取这些事件并将它们添加到MySQL数据库中。</p>
</blockquote>
<p><strong>BASE</strong>：<strong>snort</strong>的<strong>Web GUI</strong>，以图形界面查看告警信息更加利于对攻击分析和统计</p>
<blockquote>
<p>BASE（Basic Analysis and Security Engine ）是一个用于Snort的简单web GUI。替代产品包括Snorby、Splunk、Sguil、AlienVault OSSIM和任何syslog服务器。</p>
<p>之所以选择在本指南中使用BASE，是因为它设置简单，使用简单。BASE和Snorby都是废弃的项目，虽然Snorby提供了一个很好的Web-2.0接口，但由于它是用Ruby on Rails编写的，它所依赖的Ruby软件包不断升级，这导致了与其他所需Snorby软件包的兼容性问题，从而导致安装问题过多。</p>
</blockquote>
<p>界面如下：</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190720002416.png" alt=""></p>
]]></content>
      <categories>
        <category>教程</category>
        <category>snort</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>博客</tag>
        <tag>snort</tag>
        <tag>入侵检测</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PicGo和Github搭建个人图床</title>
    <url>/2019/07/17/%E4%BD%BF%E7%94%A8PicGo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="使用PicGo和Github搭建个人图床"><a href="#使用PicGo和Github搭建个人图床" class="headerlink" title="使用PicGo和Github搭建个人图床"></a>使用PicGo和Github搭建个人图床</h1><h2 id="Github设置"><a href="#Github设置" class="headerlink" title="Github设置"></a>Github设置</h2><ol>
<li><p>注册github账号，新建一个保存图片的仓库</p>
</li>
<li><p>生成一个token用于PicGo操作你的仓库</p>
</li>
<li><p>在github-&gt;setting-&gt;developer settings 选择generate new token</p>
<p>或直接访问：<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a></p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190717072230.png" alt=""></p>
<p>​        把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190717072411.png" alt=""></p>
<p>​    <strong>注意：</strong>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p>
<h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><ol>
<li><p>下载安装对应版本的PicGo</p>
<p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p>
</li>
<li><p>设置PicGO</p>
<p>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在PicGo里我要设定的仓库名就是<code>用户名/test</code>。一般我们选择<code>master</code>分支即可，然后粘贴Github生成的token。也可以在仓库下指定<code>blog</code>路径，PicGo可以自动新建<code>blog</code>目录，然后记得点击确定以生效，然后可以点击设为默认图床来确保上传的图床是GitHub。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190717073716.png" alt=""></p>
<p>当你上传的时候，你会发现你的仓库里也会增加新的图片了，图片链接自动保存在剪贴板，粘贴即可使用。</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20190717074533.png" alt=""></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2019/07/15/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol>
<li><p>安装 Node</p>
</li>
<li><p>安装 Git</p>
</li>
<li><p>安装 Hexo</p>
</li>
</ol>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>出现下图表示安装成功</p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200326231357.jpg" alt=""></p>
<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h2><ul>
<li><p>新建一个空白文件夹（下文提到的“项目根目录”是指你新建的文件夹的位置）用于存放 hexo 资源。在空白文件夹里面打开 Git Bash ，输入下列命令行进行初始化，初始化成功后会在文件夹生成如下图的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200326231433.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/hanming215/ImageRepo/master/blog/20200326231458.jpg" alt=""></p>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>打开Next主题路径下的配置文件<code>_config.yml</code>修改下列代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Canvas-nest</span><br><span class="line"></span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest</span><br><span class="line"># For more information: https:&#x2F;&#x2F;github.com&#x2F;hustcc&#x2F;canvas-nest.js</span><br><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # Display on mobile or not</span><br><span class="line">  color: &quot;0,0,255&quot; # RGB values, use &#96;,&#96; to separate</span><br><span class="line">  opacity: 0.5 # The opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # The number of lines</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>注</strong>：</p>
<ul>
<li><p>hexo相关命令均在<strong>站点目录</strong>下，用<strong>Git Bash</strong>运行。</p>
</li>
<li><p>站点配置文件：站点目录下的<code>_config.yml</code>。</p>
<p>路径为<code>&lt;folder&gt;\_config.yml</code></p>
</li>
<li><p>主题配置文件：站点目录下的<code>themes</code>文件夹下的，主题文件夹下的<code>_config.yml</code>。</p>
<p>路径为<code>&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml</code></p>
</li>
</ul>
</li>
<li><p>启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可：</p>
<blockquote>
<p>hexo server</p>
</blockquote>
</li>
<li><p>浏览器访问网址： <code>http://localhost:4000/</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
